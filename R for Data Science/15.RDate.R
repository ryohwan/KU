# 15 관계형 데이터
# 15.1 들어가기
# 데이터 분석에서 데이터프레임이 단 하나만 관련된 경우는 거의 없다.
# 일반적으로 데이터프레임이 많이 있고, 관심 있는 질문에 대답하기 위해 이들을 결합해야 한다.
# 여러 데이터프레임을 총칭하여 관계형 데이터라고 한다.
# 이렇게 부르는 이유는 중요한 것이 개별 데이터셋이 아니라 이들의 관계이기 때문이다.

# 관계라는 것은 항상 두 개의 데이터프레임 사이에서 정의된다.
# 이 간단한 개념으로부터 다른 모든 관계가 구성된다.
# 데이터프레임 3개 이상 사이의 관계는 항상 각 쌍 사이의 관계들을 이용하여 나타낼 수 있다.
# 때로는 쌍을 이루는 두 요소가 같은 데이터프레임이 될 수도 있다!
# 예를 들어 사람에 대한 데이터프레임을 가지고 있고, 각 사람이 부모에 대한 참조 정보를 가지고 있다면 이런 경우가 생긴다.

# 관계형 데이터로 작업하려면 두 개의 데이터프레임에 작동하는 동사가 필요하다.
# 관계형 데이터에 동작하도록 설계된 세 가지 동사 계열이 있다.

# 뮤테이팅(Mutating, 변형) 조인 : 다른 데이터프레임에 있는 해당 관측값에서 가져와 새로운 변수로 생성하여 추가
# 필터링 조인 : 다른 데이터프레임의 관측값와 일치하는지에 따라 관측값을 걸러냄
# 집합 연산 : 관측값을 집합 원소로 취급

# 관계형 데이터가 있는 가장 일반적인 장소는 관계형 데이터베이스 관리 시스템(RDBMS)이다.
# 이 용어는 거의 모든 현대의 데이터베이스를 포괄한다.
# 여러분이 이전에 데이터베이스를 사용했다면 SQL을 사용했을 것이 거의 확실하다.
# 그렇다면 dplyr 에서의 표현이 조금 다르긴 하지만, 이 장에 나오는 개념이 익숙할 것이다.
# 데이터베이스와 R 사이에 큰 차이가 있는 용어 하나 있는데,
# 바로, R 에서는 데이터프레임이라고 부르고
# 데이터베이스에서는 “테이블”로 부른다.
# 따라서 dplyr 문서에 1-테이블, 2-테이블에 대한 레퍼런스가 있다.
# 일반적으로 dplyr 은 SQL 보다 약간 사용하기 쉽다.
# dplyr 은 데이터 분석에 특화되었기 때문이다.
# 즉, 일반적인 데이터 분석 작업을 하기는 더 쉽게 만들었지만,
# 대신 데이터 분석에서 일반적으로 필요하지 않은 작업을 수행하기는 더 어렵게 되었다.

# 15.1.1 준비하기
# 우리는 dplyr 의 2-테이블 동사를 사용하여 nycflights13 에 있는 관계형 데이터를 탐색할 것이다.
library(tidyverse)
library(nycflights13)

# 15.2 nycflights13
# 관계형 데이터에 대해 배우기 위해 nycflights13 패키지를 사용할 것이다.
# nycflights13 패키지에는 5.1.2 장에서 사용한 flights 데이터프레임과 관련된 4 개의 티블이 있다.

# airlines 를 사용하면 해당 약어 코드로 전체 항공사명을 찾아볼 수 있다.
airlines

# airports 에는 각 공항에 대한 정보가 faa 공항 코드로 식별되어 있다.
airports

# planes 에는 각 여객기에 대한 정보가 tailnum 으로 식별되어 있다.
planes

# weather 에는 각 NYC 공항에 대한 날씨 정보가 공항 코드와 날짜로 식별되어 있다.
weather

# 이 다이어그램은 꽤 복잡해 보이지만,
# 실전에서 보게 될 것과 비교하면 간단한 것이다!
# 이와 같은 다이어그램을 이해하는 데 핵심은 각 관계가 항상 한 쌍의 데이터프레임과 관련되어 있음을 기억하는 것이다.
# 여러분은 모든 것을 이해할 필요는 없다. 관심 있는 데이터프레임 사이의 연쇄적인 관계를 이해하면 된다.

# nycflights13 에서
# flights 는 단 하나의 변수인 tailnum 을 통해 planes 에 연결된다.
# flights 는 carrier 변수를 통해 airlines 에 연결된다.
# flights 는 origin (출발지) 및 dest (목적지) 변수를 통해 두 가지 방법으로 airports 에 연결된다.
# fligths 는 origin, year, month, day, hour 를 통해 weather 에 연결된다.


# 15.3 키
# 각 데이터프레임 쌍을 연결하는 데 사용되는 변수를 키라고 한다.
# 키는 관측값을 고유하게 식별하는 변수(또는 변수 집합)이다.
# 간단한 경우 단일 변수만으로 관측값을 식별할 수 있다.
# 예를 들어 각 여객기는 tailnum 으로 고유하게 식별된다.
# 어떤 경우에는 여러 변수가 필요할 수 있다.
# 예를 들어 weather 의 관측값을 식별하려면 year, month, day, hour, origin 의 다섯 가지 변수가 필요하다.

# 두 가지 유형의 키가 있다.
# 기본키는 자신의 데이터프레임에서 관측값을 고유하게 식별한다.
# 예를 들어, planes$tailnum 은 planes 데이터프레임의 각 여객기를 고유하게 식별하므로 기본키이다.
# 외래키는 다른 데이터프레임의 관측값을 고유하게 식별한다.
# 예를 들어, flights$tailnum 은 flights 데이터프레임에서 각 항공편을 고유한 여객기와 매칭시키기 때문에 외래키이다.

# 한 변수가 동시에 기본키이며 외래키일 수 있다.
# 예를 들어 출발지는 weather 기본키의 일부이며, airport 데이터프레임의 외래키이기도 하다.
# 데이터프레임에서 기본키를 확인한 후에는 실제로 기본키가 각 관측값을 고유하게 식별하는지 확인하는 것이 좋다.
# 이를 수행하는 한 가지 방법은 기본키를 count() 하고 n 이 1보다 큰 항목을 찾는 것이다.
planes %>%
  count(tailnum) %>%
  filter(n > 1)

weather %>%
  count(year, month, day, hour, origin) %>%
  filter(n > 1)
# 때로 데이터프레임에 명시적인 기본키가 없는 경우가 있다.
# 모든 행은 관측값이지만 어떤 변수를 조합해도 각 행을 신뢰성있게 구분하지 못하는 경우이다.
# 예를 들어, flights 데이터프레임의 기본키는 무엇인가?
# 여러분은 date 에 flight 혹은 tailnum 을 더한 것으로 생각하겠지만 이들 중 어느 것도 고유하지 않다.
# flights 데이터프레임에는 명시적인 기본키가 없다.
flights %>%
  count(year, month, day, flight) %>%
  filter(n > 1)

flights %>%
  count(year, month, day, tailnum) %>%
  filter(n > 1)
# 이 데이터로 작업을 시작할 때 나는 각 항공편 번호(flight)가 하루에 한 번만 사용된다고 순진하게 추측했다.
# 그런 경우라면 특정 항공편의 문제에 대해 훨씬 쉽게 의사 소통할 수 있었을 것이었다.
# 불행히도 그것은 사실이 아니다!
# 데이터프레임에 기본키가 없으면 mutate() 와 row_number() 를 이용하여 기본키를 추가해 보라.
# 이렇게 하면 필터링을 수행하고 난 후 원래 데이터와 다시 점검할 때 관측값을 쉽게 일치시킬 수 있다.
# 이를 대체키(surrogate key) 라고 한다.

# 기본키와 이와 대응되는 다른 데이터프레임의 외래키는 관계를 형성한다.
# 관계는 대개 일대다 관계(one-to-many)이다.
# 예를 들어 각 항공편에는 여객기가 하나 있지만, 각 여객기에는 여러 항공편이 있다.
# 다른 데이터에서는 가끔 일대일 관계를 보게 된다.
# 이것을 일대다 관계의 특별한 경우라고 생각할 수 있다.
# 다대일(many-to-one) 관계와 일대다 관계를 사용하여 다대다(many-to-many) 관계를 모델링할 수 있다.
# 예를 들어 이 데이터에는 항공사(airline)와 공항(airport) 간 다대다 관계가 있다.
# 즉, 각 항공사는 많은 공항으로 운항하고, 각 공항에는 많은 항공사가 있다.

# 15.4 뮤테이팅 조인
# 한 쌍의 데이터프레임을 결합하기 위해 살펴볼 첫 번째 도구는 뮤테이팅 조인(Mutating Join) 이다.
# 뮤테이팅 조인을 사용하면 두 데이터프레임의 변수를 결합할 수 있다.
# 먼저 관측값을 키로 매칭시킨 다음 한 데이터프레임에서 다른 데이터프레임로 변수들을 복사한다.

# mutate() 와 마찬가지로 조인 함수는 오른쪽에 변수를 추가하므로 이미 많은 변수가 있는 경우 새 변수가 출력되지 않는다.
# 이 예제에서는 어떤 일이 일어나는지 더 쉽게 보기 위해 더 좁은 데이터셋을 작성한다.
flights2 <- flights %>%
  select(year:day, hour, origin, dest, tailnum, carrier)

flights2 %>%
  head()
# (RStudio에서는 View() 를 사용하여 이 문제를 피할 수도 있음을 기억하라.)

# flights2 데이터에 항공사 전체 이름을 추가하려고 한다고 가정하자.
# left_join() 으로 airlines 와 flights2 데이터프레임을 결합할 수 있다.
flights2 %>%
  select(-origin, -dest) %>%
  left_join(airlines, by = "carrier") %>%
  head()
# flights2 은 airlines 와 결합하여, 새로운 변수 name 이 추가되었다.
# 이것이 내가 이 유형의 조인을 뮤테이팅 조인이라고 부르는 이유이다.
# 이 경우 mutate() 와 R 의 베이스 서브셋작업을 사용하여 같은 위치에 도달할 수 있다.

flights2 %>%
  select(-origin, -dest) %>%
  mutate(name = airlines$name[match(carrier, airlines$carrier)]) %>%
  head()
# 뮤테이팅 조인은 조인할 변수가 많은 경우에 유용하다.
# 그러나 이 방법은 여러 변수를 매치시켜야 할 경우 일반화하기 어렵고,
# 또 전체적인 의도를 파악하기 위해서는 코드를 자세히 읽어야 한다는 단점이 있다.

# 다음 절에서는 뮤테이팅 조인의 작동 방식에 대해 자세히 설명한다.
# 우선 조인을 어떻게 시각적으로 표현하는지부터 배운다.
# 그런 다음 이를 사용하여 4개의 뮤테이팅 조인 함수,
# 즉 하나의 내부 조인(inner join)과 3개의 외부 조인(outer join)을 설명한다.
# 실제 데이터로 작업할 때 키가 항상 관측값을 고유하게 식별하지는 않기 때문에
# 다음으로는 고유한 매치가 없을 때 발생하는 상황에 대해 이야기하겠다.
# 마지막으로 조인이 정해졌을 때 어떤 변수가 이 조인의 키인지 dplyr 에 알려주는 방법을 배운다.

# 15.4.1 조인 이해하기
# 조인이 어떻게 작동하는지 배우기 위해 시각적 표현을 사용한다.
x <- tribble(
  ~key, ~val_x,
  1, "x1",
  2, "x2",
  3, "x3"
)
y <- tribble(
  ~key, ~val_y,
  1, "y1",
  2, "y2",
  4, "y3"
)
# 색상이 있는 열은 “키” 변수를 나타내며,
# 데이터프레임 사이의 행을 일치시키는 데 사용된다.
# 회색 열은 함께 따라가는 “값” 열을 나타낸다.
# 이 예제에서는 단일 키 변수와 단일 값 변수가 있지만, 다중 키와 다중 값으로 자연스럽게 일반화된다.

# 조인은 x 의 각 행을 y 의 0, 1 개 또는 여러 행에 연결하는 방법이다.
# 다음 다이어그램은 각각의 매칭 후보를 한 쌍의 선의 교차점으로 보여준다.
# 실제 조인에서는 매치 항목이 점으로 표시된다. 도트 수 = 매치 수 = 출력의 행 수이다.
# 이 예제에서는 x 의 각 행이 y 의 한 행에만 매칭되므로, x 의 행 수와 y 의 행 수가 동일하다.
# 이 경우 조인은 외부 조인(outer join)이다.
# 외부 조인은 x 의 행 수와 y 의 행 수가 동일하지 않은 경우에도 동일하게 작동한다.
# 외부 조인은 두 데이터프레임의 행 수가 동일하지 않은 경우에도 동일하게 작동한다.

# 15.4.2 내부 조인
# 가장 간단한 조인 유형은 내부 조인 이다. 내부 조인은 키가 같을 때마다 두 관측값을 매칭한다.

# (정확하게 말하면 같음연산자(equality operator)를 사용하여 키가 매치되기 때문에
# 내부 동등 조인(equijoin) 이다.
# 대부분의 조인은 동등 조인이므로 우리는 일반적으로 이러한 상세한 내용을 생략한다.)

# 내부 조인(inner join)의 출력은 키, x 값 및 y 값을 포함하는 새로운 데이터프레임이다.
# by 를 사용하여 어떤 변수가 키인지를 지정한다.

x %>%
  inner_join(y, by = "key")
# 내부 조인의 가장 중요한 특성은 매칭되지 않는 행은 결과에 포함되지 않는다는 점이다.
# 즉, 내부 조인은 관측값을 잃어버리기 쉽기 때문에 일반적으로 분석에 사용하기에 적합하지 않다.

# 15.4.3 외부 조인
# 내부 조인에서는 두 데이터프레임 모두에 나타나는 관측값이 보존된다.
# 외부 조인(outer join)에서는 적어도 하나의 데이터프레임에 있는 관측값은 보존된다.
# 외부 조인에는 세 가지 유형이 있다.

# 왼쪽 조인(left join) 은 x 의 모든 관측값을 보존한다.
# 오른쪽 조인(right join) 은 y 의 모든 관측값을 보존한다.
# 전체 조인(full join) 은 x 와 y 의 모든 관측값을 보존한다.

# 이러한 조인은 각 데이터프레임에 ’가상’ 관측값을 추가하여 작동한다.
# 이 관측값에는 항상 매칭되는 키 (다른 키가 매칭되지 않는 경우)와 NA 로 채워진 값이 있다.

# 15.4.4 중복키
# 지금까지 모든 데이터프레임은 키가 고유하다고 가정했다.
# 하지만 항상 그런 것은 아니다. 이 절에서는 키가 고유하지 않은 경우 어떻게 되는지 설명한다. 두 가지 경우가 있다.

# 1. 하나의 데이터프레임에 중복키가 있다. 중복키는 추가적인 정보를 넣을 때 유용한데 일반적으로 일대다 관계가 있기 때문이다.
# 출력에서 약간 다른 위치에 키 열을 놓은 것을 확인하라. 이것은 키가 y 의 기본키이고 x 의 외래키임을 보여준다.
x <- tribble(
  ~key, ~val_x,
  1, "x1",
  2, "x2",
  2, "x3",
  1, "x4"
)
y <- tribble(
  ~key, ~val_y,
  1, "y1",
  2, "y2"
)
left_join(x, y, by = "key")
#> # A tibble: 4 × 3
#>     key val_x val_y
#>   <dbl> <chr> <chr>
#> 1     1 x1    y1
#> 2     2 x2    y2
#> 3     2 x3    y2
#> 4     1 x4    y1

# 2. 두 데이터프레임 모두에 중복키가 있다. 이 경우 조인은 두 데이터프레임의 모든 행을 보존한다.
# 이 경우 조인은 두 데이터프레임의 모든 행을 보존한다.
# 출력에서 약간 다른 위치에 키 열을 놓은 것을 확인하라. 이것은 키가 x 와 y 의 기본키임을 보여준다.
x <- tribble(
  ~key, ~val_x,
  1, "x1",
  2, "x2",
  2, "x3",
  3, "x4"
)
y <- tribble(
  ~key, ~val_y,
  1, "y1",
  2, "y2",
  2, "y3",
  3, "y4"
)
left_join(x, y, by = "key")
#> # A tibble: 6 × 3
#>     key val_x val_y
#>   <dbl> <chr> <chr>
#> 1     1 x1    y1
#> 2     2 x2    y2
#> 3     2 x2    y3
#> 4     2 x3    y2
#> 5     2 x3    y3
#> 6     3 x4    y4

# 15.4.5 키열 정의하기
# 지금까지 데이터프레임 쌍은 항상 하나의 변수에 의해 조인되었으며 그 변수는 두 데이터프레임에서 같은 이름을 가졌었다.
# 그 제약은 by = "key" 로 코드화되었다. by 에 다른 값을 사용하여 다른 방법으로 데이터프레임을 연결할 수 있다.

# 기본값 by = NULL 을 사용하면 두 데이터프레임에 있는 모든 변수를 사용하며 이는 자연 조인(natural join)이라 부른다.
# 예를 들어 flights 및 weather 데이터프레임은 공통 변수인 year, month, day, hour, origin 으로 매치된다.
flights2 %>%
  left_join(weather) %>%
  head()

# 문자형 벡터 by = "x". 이것은 자연 결합과 같지만 일부 공통 변수만 사용한다.
# 예를 들어 flights 와 planes 에는 year 변수가 있지만
# 서로 다른 의미이므로 tailnum 으로만 조인하고 싶다.
flights2 %>%
  left_join(planes, by = "tailnum") %>%
  head()





